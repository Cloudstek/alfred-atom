// @flow

const color = require('color');
const fs = require('fs');
const Hugo = require('alfred-hugo');
const path = require('path');
const svgexport = require('svgexport');

const octicons = require('octicons');
const octiconsPath = path.join(path.dirname(require.resolve('octicons')), 'build', 'svg');

class Icons {
    /**
     * SVG icon path color
     * @return {string}
     */
    _pathColor(): string {
        let iconColor = color('#FFFFFF');

        // Decide color based on text or background color
        if (Hugo.alfredThemeFile) {
            try {
                iconColor = color(Hugo.alfredTheme.result.text.color);
            } catch (e) {}
        } else if (process.env.alfred_theme_background) {
            let bgColor = color(process.env.alfred_theme_background);
            iconColor = bgColor.grayscale().negate();
        }

        return iconColor.rgb().string();
    }

    /**
     * Rebuild icon(s)
     * @param {Array.Object} projects
     * @param {Object} options
     * @return {Promise}
     * @async
     */
    async rebuild(projects: Array<Object>, options: Object = {}) {
        // Output path
        const iconPath = path.join(__dirname, 'icons');

        // Octicon names
        const octiconNames = Object.keys(octicons);

        // Icons to render
        let icons = [];

        // Icon size
        let iconSize = 64;

        // Render queue
        let renderQueue = [];

        // Get used icons from projects list
        for (let i = 0; i < projects.length; i++) {
            if (!projects[i].hasOwnProperty('icon')) {
                continue;
            }

            let icon = path.parse(projects[i].icon.path);

            if (icon.dir === iconPath && octiconNames.indexOf(icon.name) >= 0) {
                if (icons.indexOf(icon.name) === -1) {
                    icons.push(icon.name);
                }
            }
        }

        // Filter icons
        if (options && options.onlyMissing === true) {
            icons = icons.filter(icon => {
                try {
                    fs.statSync(path.join(iconPath, icon + '.png'));
                    return false;
                } catch (e) {
                    return true;
                }
            });
        }

        if (icons.length === 0) {
            return;
        }

        if (Hugo.alfredThemeFile) {
            try {
                iconSize = Hugo.alfredTheme.result.iconSize;
            } catch (e) {}
        }

        // Render options
        let renderOptions = [iconSize + ':' + iconSize, 'pad', 'path{fill:' + this._pathColor() + '}'];

        // Build render queue
        for (let i = 0; i < icons.length; i++) {
            let icon = icons[i];

            if (icon && icon.length > 0) {
                renderQueue.push({
                    input: path.join(octiconsPath, icon + '.svg'),
                    output: [
                        [path.join(iconPath, icon + '.png'), ...renderOptions]
                    ]
                });
            }
        }

        // Render
        svgexport.render(renderQueue, err => {
            if (err) {
                throw err;
            }
        });
    }
}

module.exports = new Icons();
