{"version":3,"sources":["icons.js.flow"],"names":["color","require","fs","Hugo","path","octicons","octiconsPath","join","dirname","resolve","svgexport","err","Icons","iconColor","alfredMeta","themeFile","alfredTheme","result","text","e","process","env","alfred_theme_background","bgColor","grayscale","negate","rgb","string","projects","icons","octiconNames","iconPath","__dirname","project","hasOwnProperty","icon","parse","dir","indexOf","name","push","options","iconSize","renderQueue","usedIcons","onlyMissing","filter","statSync","length","renderOptions","_pathColor","input","output","notify","message","render","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst color = require('color');\nconst fs = require('fs');\nconst Hugo = require('alfred-hugo');\nconst path = require('path');\n\nconst octicons = require('octicons');\nconst octiconsPath = path.join(path.dirname(require.resolve('octicons')), 'build', 'svg');\n\n// Svgexport is optional\nvar svgexport = null;\ntry {\n    svgexport = require('svgexport') || null;\n} catch (err) {}\n\nclass Icons {\n    /**\n     * SVG icon path color\n     *\n     * @return {string} SVG icon color as hex RGB\n     */\n    _pathColor(): string {\n        let iconColor = color('#FFFFFF');\n\n        // Decide color based on text or background color\n        if (Hugo.alfredMeta.themeFile) {\n            try {\n                iconColor = color(Hugo.alfredTheme.result.text.color);\n            } catch (e) {}\n        } else if (process.env.alfred_theme_background) {\n            let bgColor = color(process.env.alfred_theme_background);\n            iconColor = bgColor.grayscale().negate();\n        }\n\n        return iconColor.rgb().string();\n    }\n\n    /**\n     * Get list of used icons in projects\n     *\n     * @param {Array.Object} projects List of Atom project definitions\n     *\n     * @return {Array.string} List of icons\n     */\n    usedIcons(projects: Array<Object>): Array<string> {\n        let icons = [];\n\n        // Octicon names\n        const octiconNames = Object.keys(octicons);\n\n        // Output path\n        const iconPath = path.join(__dirname, 'icons');\n\n        for (let project of projects) {\n            if (!project.hasOwnProperty('icon')) {\n                continue;\n            }\n\n            let icon = path.parse(project.icon.path);\n\n            if (icon.dir === iconPath && octiconNames.indexOf(icon.name) >= 0) {\n                if (icons.indexOf(icon.name) === -1) {\n                    icons.push(icon.name);\n                }\n            }\n        }\n\n        return icons;\n    }\n\n    /**\n     * Check icon building dependencies\n     *\n     * @return {boolean} True if all icon dependencies are available\n     */\n    checkDependencies(): boolean {\n        try {\n            require.resolve('svgexport');\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Rebuild icon(s)\n     *\n     * @param {Array.Object} projects List of Atom project definitions\n     * @param {Object} options Options\n     * @return {Promise} Async promise\n     * @async\n     */\n    async rebuild(projects: Array<Object>, options: Object = {}) {\n        if (!svgexport) {\n            return false;\n        }\n\n        // Output path\n        const iconPath = path.join(__dirname, 'icons');\n\n        // Icon size\n        let iconSize = 64;\n\n        // Render queue\n        let renderQueue = [];\n\n        // Get used icons from projects list\n        let icons = this.usedIcons(projects);\n\n        // Filter icons\n        if (options && options.onlyMissing === true) {\n            icons = icons.filter(icon => {\n                try {\n                    fs.statSync(path.join(iconPath, icon + '.png'));\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            });\n        }\n\n        if (icons.length === 0) {\n            return;\n        }\n\n        // Icon size if set by theme\n        if (Hugo.alfredTheme.result && Hugo.alfredTheme.result.iconSize) {\n            iconSize = Hugo.alfredTheme.result.iconSize;\n        }\n\n        // Render options\n        let renderOptions = [iconSize + ':' + iconSize, 'pad', 'path{fill:' + this._pathColor() + '}'];\n\n        // Build render queue\n        for (let icon of icons) {\n            if (icon && icon.length > 0) {\n                renderQueue.push({\n                    input: path.join(octiconsPath, icon + '.svg'),\n                    output: [\n                        [path.join(iconPath, icon + '.png'), ...renderOptions]\n                    ]\n                });\n            }\n        }\n\n        // Show notification\n        Hugo.notify({\n            message: `Rebuilding ${renderQueue.length} project icons, please wait.`\n        });\n\n        // Render\n        svgexport.render(renderQueue, err => {\n            if (err) {\n                throw err;\n            }\n        });\n    }\n}\n\nmodule.exports = new Icons();\n"],"file":"icons.js"}